#define BA {B001100,B011110,B110011,B110011,B110011,B110011,B111111,B111111,B111111,B110011,B110011,B110011}
#define BB {B111110,B111111,B110011,B110011,B111100,B111110,B111110,B111100,B110011,B110011,B111111,B111110}
#define BC {B011111,B111111,B111000,B111000,B111000,B111000,B111000,B111000,B111000,B111000,B111111,B011111}
#define BD {B111110,B111111,B110011,B110011,B110011,B110011,B110011,B110011,B110011,B110011,B111111,B111110}
#define BE {B111111,B111111,B110000,B110000,B110000,B111111,B111111,B110000,B110000,B110000,B111111,B111111}
#define BF {B111111,B111111,B110000,B110000,B110000,B110000,B111111,B111111,B110000,B110000,B110000,B110000}
#define BG {B011111,B111111,B110001,B110000,B110000,B110111,B110111,B110001,B110011,B110011,B111111,B111110}
#define BH {B110011,B110011,B110011,B110011,B110011,B111111,B111111,B110011,B110011,B110011,B110011,B110011}
#define BI {B1111,B1111,B0110,B0110,B0110,B0110,B0110,B0110,B0110,B0110,B1111,B1111}
#define BJ {B000011,B000011,B000011,B000011,B000011,B000011,B000011,B110011,B110011,B110011,B111111,B011111}
#define BK {B110011,B110011,B110110,B110110,B111110,B111100,B111100,B111110,B110110,B110110,B110011,B110011}
#define BL {B111000,B110000,B110000,B110000,B110000,B110000,B110000,B110000,B110000,B110001,B111111,B111111}
#define BM {B11100111,B11100111,B11100111,B11011011,B11011011,B11011011,B11011011,B11000011,B11000011,B11000011,B11000011,B11000011}
#define BN {B11100011,B11100011,B11110011,B11110011,B11011011,B11011011,B11011011,B11011011,B11001111,B11001111,B11000111,B11000111}
#define BO {B011110,B111111,B110011,B110011,B110011,B110011,B110011,B110011,B110011,B110011,B111111,B011110}
#define BP {B111100,B110110,B110011,B110011,B110011,B110110,B111100,B110000,B110000,B110000,B110000,B110000}
#define BQ {B011110,B111111,B110011,B110011,B110011,B110011,B111011,B110111,B110111,B110011,B111111,B011110}
#define BR {B111100,B110110,B110011,B110011,B110011,B110110,B111100,B111100,B110110,B110110,B110011,B110011}
#define BS {B011111,B111111,B110000,B011000,B011000,B011100,B011100,B001100,B000110,B000011,B111111,B111110}
#define BT {B111111,B111111,B101101,B001100,B001100,B001100,B001100,B001100,B001100,B001100,B001100,B011110}
#define BU {B110011,B110011,B110011,B110011,B110011,B110011,B110011,B110011,B110011,B111111,B111111,B011110}
#define BV {B110011,B110011,B110011,B110011,B110011,B110011,B110011,B110011,B110011,B011110,B011110,B001100}
#define BW {B11000011,B11000011,B11000011,B11000011,B11011011,B11011011,B11011011,B11011011,B11100111,B11100111,B11100111,B11000011}
#define BY {B110011,B110011,B110011,B110011,B010010,B010010,B010010,B001100,B001100,B001100,B001100,B001100}
#define NUM0 {B011110,B110011,B110011,B110011,B110111,B110111,B111011,B111011,B110011,B110011,B110011,B011110}
#define NUM1 {B000111,B011111,B011011,B110011,B000011,B000011,B000011,B000011,B000011,B000011,B000011,B000111}
#define NUM2 {B111110,B111111,B000011,B000110,B000110,B001100,B001100,B011000,B011000,B110000,B111111,B111111}
#define NUM3 {B111110,B111111,B000011,B000110,B000110,B111100,B111100,B000110,B000110,B000011,B111111,B111110}
#define NUM4 {B110011,B110011,B110011,B110011,B110011,B111111,B111111,B111111,B000011,B000011,B000011,B000011}
#define NUM5 {B111111,B111111,B110000,B110000,B110000,B111110,B111111,B000011,B000011,B100111,B111110,B111100}
#define NUM6 {B011111,B111111,B110001,B110000,B110000,B111110,B111111,B110011,B110011,B110011,B111111,B111110}
#define NUM7 {B011111,B111111,B000011,B000110,B000110,B001100,B001100,B011000,B011000,B110000,B110000,B000000}
#define NUM8 {B011110,B111111,B110011,B110011,B110011,B011110,B011110,B110011,B110011,B110011,B111111,B011110}
#define NUM9 {B011110,B111111,B110011,B110011,B110011,B111111,B011111,B000011,B000011,B100011,B111110,B111100}
#define SPACE {B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0000}
#define LINE {B0000,B0000,B0000,B0000,B1111,B1111,B1111,B1111,B0000,B0000,B0000,B0000}
#define DOT {B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0110,B0110,B0110,B0110}
#define COMMA {B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0000,B0110,B0110,B1100}

int latchPin = 10;
int clockPin = 13;
int dataPin = 11;
int clock = 9;
int Reset = 8;
int latchPinPORTB = latchPin - 8;
int clockPinPORTB = clockPin - 8;
int dataPinPORTB = dataPin - 8;
int i = 0;
long scrolling_word[12];
int array_turn=0;
byte your_text[][12]={BJ,BU,BT,BE,SPACE,BK,BH,BA,BT,BT,BE,SPACE,BE,BN,BG,BI,BN,BE,BE,BR,BI,BN,BG,SPACE,BC,BO,BN,BS,BU,BL,BT,BA,BN,BC,BE,SPACE,SPACE,SPACE,BB,BA,BN,BG,BA,BN,BG,BA,LINE,NUM0,NUM7,SPACE,BK,BO,BI,BL,BI,SPACE,BB,BA,BN,BG,BA,BI,BN,SPACE,SPACE,SPACE,BC,BO,BN,BT,BA,BC,BT,SPACE,BE,BR,DOT,BN,BA,BW,BA,BR,BA,BJ,SPACE,BP,BA,BN,BD,BE,BY,SPACE,SPACE,NUM9,NUM8,NUM5,NUM1,NUM1,NUM7,NUM7,NUM5,NUM8,NUM0};//PUT YOU TEXT HERE


void setup(){
  Serial.begin(9600);
  pinMode(dataPin,OUTPUT);
  pinMode(clockPin,OUTPUT);
  pinMode(latchPin,OUTPUT);
  pinMode(clock,OUTPUT);
  pinMode(Reset,OUTPUT);
  digitalWrite(Reset,HIGH);
  digitalWrite(Reset,LOW);
  setupSPI();
}

void display_word(int loops,byte word_print[][12],int num_patterns,int delay_langth){// this function displays your symbols
  i = 0;// resets the counter fot the 4017
  
  for(int g=0;g<12;g++)//resets the the long int where your word goes
    scrolling_word[g] = 0;
    
  for(int x=0;x<num_patterns;x++){//main loop, goes over your symbols
   // you will need to find a better way to make the symbols scroll my way is limited for 24 columns

   for(int r=0;r<12;r++)//puts the buildes the first symbol
      scrolling_word[r] |= word_print[x][r]; 
      
    for (int z=0;z<12;z++){//the sctolling action
    
        for(int p=0;p<12;p++)
          scrolling_word[p] = scrolling_word[p] << 1;
          
// end of the scrolling funcion
      for(int t=0;t<delay_langth;t++){// delay function, it just loops over the same display
      
        for(int y=0;y<12;y++){// scaning the display
        
          if(i == 12){// counting up to 6 with the 4017
            digitalWrite(Reset,HIGH);
            digitalWrite(Reset,LOW);
            i = 0;
          }
          latchOff();
          spi_transfer(make_word(0x01000000000000000000,y));// sending the data
          spi_transfer(make_word(0x00010000000000000000,y));
          spi_transfer(make_word(0x00000100000000000000,y));
          spi_transfer(make_word(0x00000001000000000000,y));// sending the data
          spi_transfer(make_word(0x00000000010000000000,y));
          spi_transfer(make_word(0x00000000000100000000,y));
          spi_transfer(make_word(0x00000000000001000000,y));// sending the data
          spi_transfer(make_word(0x00000000000000010000,y));
          spi_transfer(make_word(0x00000000000000000100,y));
          latchOn();
          
          delayMicroseconds(500);//waiting a bit
          latchOff();
          spi_transfer(0);// clearing the data
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);// clearing the data
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);// clearing the data
          spi_transfer(0);
          spi_transfer(0);
          
          latchOn();
          digitalWrite(clock,HIGH);//counting up with the 4017
          digitalWrite(clock,LOW);
          i++;
        }
      }
    }
  }
  finish_scroll(delay_langth);
}

void finish_scroll(int delay_scroll){// this function is the same as the funcion above, it just finishing scrolling
  for (int n=0;n<72;n++){
        for(int h=0;h<12;h++)
          scrolling_word[h] = scrolling_word[h] << 1;
      for(int w=0;w<delay_scroll;w++){
        for(int k=0;k<12;k++){
          if(i == 12){
            digitalWrite(Reset,HIGH);
            digitalWrite(Reset,LOW);
            i = 0;
          }
          latchOff();
          spi_transfer(make_word(0x01000000000000000000,k));// sending the data
          spi_transfer(make_word(0x00010000000000000000,k));
          spi_transfer(make_word(0x00000100000000000000,k));
          spi_transfer(make_word(0x00000001000000000000,k));// sending the data
          spi_transfer(make_word(0x00000000010000000000,k));
          spi_transfer(make_word(0x00000000000100000000,k));
          spi_transfer(make_word(0x00000000000001000000,k));// sending the data
          spi_transfer(make_word(0x00000000000000010000,k));
          spi_transfer(make_word(0x00000000000000000100,k));
          latchOn();
          delayMicroseconds(500);
          latchOff();
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);
          spi_transfer(0);
          latchOn();
          digitalWrite(clock,HIGH);
          digitalWrite(clock,LOW);
          i++;
        }
      }
    }
}

byte make_word (long posistion,byte turn){
  byte dummy_word = 0;
  for(int q=0;q<10;q++){
    if(scrolling_word[turn] & (posistion<<q))
      dummy_word |= 0x01<<q;
  }
  return dummy_word;
}   


  void loop() {

        display_word(1,your_text,103,20);// calls for the display_pattern function and says that int loop = 15(if you do more loop the pattern whould scrole slower).
   
       }
  
  

void latchOn(){
  bitSet(PORTB,latchPinPORTB);
}

void latchOff(){
  bitClear(PORTB,latchPinPORTB);
}


void setupSPI(){
  byte clr;
  SPCR |= ( (1<<SPE) | (1<<MSTR) ); // enable SPI as master
  //SPCR |= ( (1<<SPR1) | (1<<SPR0) ); // set prescaler bits
  SPCR &= ~( (1<<SPR1) | (1<<SPR0) ); // clear prescaler bits
  clr=SPSR; // clear SPI status reg
  clr=SPDR; // clear SPI data reg
  SPSR |= (1<<SPI2X); // set prescaler bits
  //SPSR &= ~(1<<SPI2X); // clear prescaler bits

  delay(10);
}
byte spi_transfer(byte data)
{
  SPDR = data;			  // Start the transmission
  while (!(SPSR & (1<<SPIF)))     // Wait the end of the transmission
  {
  };
  return SPDR;			  // return the received byte, we don't need that
}



